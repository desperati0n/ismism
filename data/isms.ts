// 主义主义数据库 - 模拟数据
// 格式: "1-2-3-4" 或包含 $ 的组合

export interface Ism {
  code: string; // 例如 "1-2-3-4" 或 "$-1-2-3"
  name: string;
  description: string;
}

export const ismsDatabase: Ism[] = [
  // $ 在第一位（主体性缺失）的特殊组合
  {
    code: '$-1-2-3',
    name: '虚无理想主义',
    description: '当主体性缺失遇见理想、理性与传统，形成一种对意义的深刻质疑。这种主义认为，在失去主体的前提下，任何理想都是虚构的，理性是空洞的，传统是无根的。',
  },
  {
    code: '$-2-3-4',
    name: '漂流存在主义',
    description: '主体性的缺失使得理性、传统与行动都失去了锚点。这是一种漂泊的存在状态，既无法回到传统，也无法通过理性找到方向，只能在行动中寻找临时的意义。',
  },
  {
    code: '$-1-1-1',
    name: '空想乌托邦主义',
    description: '在主体性缺失的情况下，纯粹的理想堆叠成为一种空中楼阁。这种主义沉迷于美好的幻想，却无法落地，因为没有真实的主体去承载和实现这些理想。',
  },
  {
    code: '$-4-4-4',
    name: '机械行动主义',
    description: '失去主体性后的纯粹行动，像机器一样运转，没有反思，没有目的，只有不断的运动本身。这是一种最彻底的异化状态。',
  },
  {
    code: '$-1-2-4',
    name: '虚无实践主义',
    description: '在主体性缺失的背景下，理想与理性的结合也无法产生真实的行动力。一切实践都变成了无意义的重复，缺乏内在的驱动力。',
  },
  {
    code: '$-3-2-1',
    name: '传统回溯虚无主义',
    description: '当传统、理性和理想都在主体性缺失的阴影下失去意义，唯一剩下的是一种向后的回望，但回望的尽头也是虚无。',
  },
  
  // 标准数字组合
  {
    code: '1-2-3-4',
    name: '理性进步主义',
    description: '结合理想、理性、传统与行动，追求通过理性思考和实际行动，在尊重传统的基础上实现理想的进步。这是一种平衡而全面的世界观。',
  },
  {
    code: '1-1-1-1',
    name: '纯粹理想主义',
    description: '将理想视为唯一追求，相信通过不懈的理想追求可以改变世界。这种主义充满热情但可能脱离现实，容易陷入乌托邦式的幻想。',
  },
  {
    code: '2-2-2-2',
    name: '极端理性主义',
    description: '认为理性是解决一切问题的唯一工具。过度依赖逻辑和分析，可能忽视情感、直觉和人性的复杂面向。',
  },
  {
    code: '3-3-3-3',
    name: '保守传统主义',
    description: '强调传统、习俗和既有秩序的价值，抗拒变革和创新。认为祖先的智慧是最可靠的指引，但可能导致僵化和停滞。',
  },
  {
    code: '4-4-4-4',
    name: '激进行动主义',
    description: '强调实践高于一切，通过不断的行动来创造变化。可能缺乏深思熟虑，导致盲目的运动和无效的努力。',
  },
  {
    code: '1-2-1-2',
    name: '理想理性循环主义',
    description: '在理想与理性之间不断循环，用理性检验理想，用理想激发理性。这是一种自我完善的思维模式，但可能陷入过度内省。',
  },
  {
    code: '3-4-3-4',
    name: '传统行动交替主义',
    description: '在传统与行动之间摇摆，既想保持传统，又想通过行动改变现状。这种矛盾可能导致犹豫不决，也可能形成稳健的变革路径。',
  },
  {
    code: '1-4-1-4',
    name: '理想实践往复主义',
    description: '在理想与实践之间来回试探，不断用行动检验理想，用理想指导行动。这是一种务实的理想主义。',
  },
  {
    code: '2-3-2-3',
    name: '理性传统辩证主义',
    description: '在理性分析与传统智慧之间寻找平衡，既不盲从传统，也不完全抛弃历史经验。这是一种温和的改革主义。',
  },
  
  // 包含通配符 $ 的组合（非第一位）- 这些不应该存在于数据库中，因为数据库存储的是具体模块
  // 但搜索时可以用 $ 作为通配符
  
  // 更多有趣的组合
  {
    code: '4-3-2-1',
    name: '逆行反思主义',
    description: '从行动开始，回溯到传统，再通过理性反思，最终回到理想。这是一种从实践中提炼智慧的路径。',
  },
  {
    code: '1-3-2-4',
    name: '理想传统理性行动主义',
    description: '以理想为起点，借鉴传统智慧，通过理性规划，最终付诸行动。这是一种系统而稳健的进路。',
  },
  {
    code: '3-1-4-2',
    name: '传统理想行动反思主义',
    description: '从传统出发，重新发现理想，通过行动实践，最后用理性总结。这是一种周期性的发展模式。',
  },
  {
    code: '2-4-1-3',
    name: '理性行动理想传统综合主义',
    description: '理性规划行动，行动激发理想，理想连接传统。这是一种复杂而动态的世界观，强调各要素的互动和转化。',
  },
  {
    code: '2-1-3-4',
    name: '理性理想传统行动主义',
    description: '以理性分析为起点，发现理想，尊重传统，最终通过行动实现。这是一种理性的理想主义路径。',
  },
  {
    code: '4-2-1-3',
    name: '行动理性理想传统主义',
    description: '从实际行动出发，通过理性总结，发现理想，最终回归传统。这是一种从实践中升华的路径。',
  },
];

// 搜索函数：支持精确匹配和通配符匹配
// 重要：第一个格子的 $ 代表"主体性缺失"，应该匹配所有 $-x-x-x 格式的模块
// 其他格子的 $ 作为通配符，匹配任意值（1-4）
export function searchIsms(searchCode: string): Ism[] {
  const searchParts = searchCode.split('-');
  
  // 如果长度不是 4，返回空数组
  if (searchParts.length !== 4) return [];
  
  const results = ismsDatabase.filter((ism) => {
    const ismParts = ism.code.split('-');
    
    // 如果数据库模块的长度不是 4，跳过
    if (ismParts.length !== 4) return false;
    
    // 特殊处理：第一个格子为 $ 的情况
    if (searchParts[0] === '$') {
      // 第一个格子的 $ 代表"主体性缺失"，必须匹配数据库中以 $- 开头的模块
      if (ismParts[0] !== '$') return false;
      
      // 对于剩余的 3 位，进行匹配（$ 在其他位置作为通配符）
      for (let i = 1; i < 4; i++) {
        const searchPart = searchParts[i];
        const ismPart = ismParts[i];
        
        // 如果搜索码的这一位是 $，匹配任何值（但不能是 $，因为数据库中没有非第一位为 $ 的模块）
        if (searchPart === '$') continue;
        
        // 否则必须精确匹配
        if (searchPart !== ismPart) return false;
      }
      
      return true;
    }
    
    // 第一个格子不是 $ 的情况：第一个格子必须精确匹配（不能是 $）
    if (ismParts[0] === '$') return false; // 数据库中第一个为 $ 的模块不应该匹配第一个格子不是 $ 的搜索
    if (searchParts[0] !== ismParts[0]) return false;
    
    // 对于剩余的 3 位，进行匹配
    for (let i = 1; i < 4; i++) {
      const searchPart = searchParts[i];
      const ismPart = ismParts[i];
      
      // 如果搜索码的这一位是 $，匹配任何值（1-4）
      if (searchPart === '$') continue;
      
      // 否则必须精确匹配
      if (searchPart !== ismPart) return false;
    }
    
    return true;
  });
  
  return results;
}

